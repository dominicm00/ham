/*
 * Copyright 2022, Dominic Martinez, dom@dominicm.dev.
 * Distributed under the terms of the MIT License.
 */

#include "make/Piecemeal.hpp"

#include "code/Leaf.hpp"
#include "data/Target.hpp"
#include "make/Command.hpp"
#include "make/MakeException.hpp"

#include <cmath>
#include <sstream>
#include <vector>

namespace ham::make
{

data::StringListList
Piecemeal::Words(
	code::EvaluationContext context,
	std::string actionName,
	std::vector<std::pair<std::string_view, std::string_view>> words,
	StringList boundSources,
	std::size_t maxLine
)
{
	/* Calculate the size of the command with a given source list to split
	 * commands up with the `piecemeal` modifier.
	 *
	 * To calculate the size of the command, split the command into
	 * whitespace-separated words, calculate the size of each word, and then sum
	 * the total of word and whitespace.
	 *
	 * To calculate the size of a word:
	 *
	 * Let `eval` represent evaluating the word with a given source set.
	 *
	 * Let word groups be all the words generated by a specific combination of
	 * source elements (i.e. the constant words generated by the product of
	 * other variables).
	 *
	 * Let `length1 := eval{"a"}` and `length2 := eval{"a", "b"}`. The source
	 * _power_, or how many times the source variable is included in the word,
	 * is `log2(length2/length1)`. Because other variables are constant, this
	 * accounts for nested variables holding the source variable.
	 *
	 * Let `length1 := eval{"a"}` and `length2 := eval{"ab"}`. `length2 -
	 * length1 - power + 1` is the source _multiplicity_, or how many times
	 * each source is included in the word because of external variable
	 * products. `length1 - (length2 - length1) = 2*length1 - length2` is also
	 * the base length of the word group.
	 *
	 * Say we are given the length of a word with a source set of length `L`. We
	 * add a new source of length `S`. The additional length created is
	 * `baseLength + multiplicity*S`
	 *
	 * The empty set has length 0, so via induction we can build up to any
	 * source set.
	 *
	 * NOTE: An earlier version of this algorithm accounted for high power
	 * sources (e.g. `$(2)-$(2)`), but because of ADR 7 we only have to account
	 * for the linear case.
	 */
	data::StringListList piecemealSources{};

	// Helpers
	const auto genDomain = [context](std::vector<const char*> vars) {
		StringList list{};
		for (auto var : vars) {
			list.Append(var);
		}

		// Inherit from existing domain
		data::VariableDomain domain{*(context.BuiltInVariables())};
		domain.Set("2", list);
		domain.Set(">", list);
		return domain;
	};

	auto oldDomain = context.BuiltInVariables();

	// Includes trailing space for length to be consistent
	const auto getLength =
		[&oldDomain,
		 &context](data::VariableDomain* domain, std::string_view word) {
		context.SetBuiltInVariables(domain);
		const StringList list = code::Leaf::EvaluateString(
			context,
			word.cbegin(),
			word.cend(),
			nullptr
		);
		context.SetBuiltInVariables(oldDomain);

		std::size_t length = 0;
		for (std::size_t i = 0; i < list.Size(); i++) {
			// Add joined spaces
			length += list.ElementAt(i).Length() + 1;
		}
		return length;
	};

	// Test variable domains
	auto singleDomain = genDomain({"a"});
	auto longDomain = genDomain({"ab"});
	auto dualDomain = genDomain({"a", "b"});

	// Calculate basic word info
	std::vector<std::tuple<std::size_t, std::size_t>> wordInfo{};
	std::size_t baseCommandSize = 0;
	for (const auto& [word, space] : words) {
		const std::size_t singleLength = getLength(&singleDomain, word);
		const std::size_t longLength = getLength(&longDomain, word);
		const std::size_t dualLength = getLength(&dualDomain, word);

		if (singleLength == 0 || longLength == 0 || dualLength == 0)
			throw MakeException("Failed to calculate word length");

		if (dualLength % singleLength != 0)
			throw MakeException("Impossible variable expansion length");

		// (ADR 7) High power sources are forbidden
		const std::size_t power =
			std::round(std::log2((double)dualLength / singleLength));
		if (power > 1) {
			std::stringstream error{};
			error << "Word " << word << " in piecemeal action " << actionName
				  << " contains the source variable ($(2)/$(>)) more than once";
			throw MakeException(error.str());
		}

		const std::size_t baseLength = 2 * singleLength - longLength;
		const std::size_t multiplicity = longLength - singleLength - power + 1;

		// Count whitespace as constant
		baseCommandSize += space.length();

		// If word is a constant, add length directly to command
		if (power == 0) {
			baseCommandSize += baseLength - 1;
		} else {
			wordInfo.push_back({baseLength, multiplicity});
		}
	}

	// Piecemeal sources
	StringList sources{};
	double averageLength = 0;
	std::size_t commandSize = baseCommandSize;
	for (std::size_t i = 0; i < boundSources.Size(); i++) {
		auto source = boundSources.ElementAt(i);

		// Calculate size of added source
		for (const auto& [baseLength, multiplicity] : wordInfo) {
			commandSize += baseLength + multiplicity * source.Length();
		}

		// Each (non-constant) word has a trailing space that is included for
		// the incremental length calculation, but is not included in the final
		// command.
		if (commandSize - wordInfo.size() > maxLine) {
			if (sources.IsEmpty()) {
				std::stringstream error;
				error << "maxline of " << maxLine
					  << " is too small; unable to add source "
					  << source.ToStlString();
				throw MakeException(error.str());
			}

			piecemealSources.push_back(sources);
			sources = {};
			averageLength = 0;
			commandSize = baseCommandSize;
			i--; // redo calculation with current source
		} else {
			averageLength = (sources.Size() * averageLength + source.Length())
				/ (sources.Size() + 1);
			sources.Append(source);
		}
	}

	if (!sources.IsEmpty())
		piecemealSources.push_back(sources);

	return piecemealSources;
}

} // namespace ham::make
